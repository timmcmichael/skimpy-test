:imagesdir: images
:sourcedir: source
// The following corrects the directories if this is included in the main file.
ifeval::["{docname}" == "main"]
:imagesdir: chapter-1-coding/images
:sourcedir: chapter-1-coding/source
endif::[]
== 0001 - Computers and Coding (Chapter 1)

=== What's the Point?
* Understand the role of programming languages
* Get to know a little about Object-Oriented Programming (OOP)

'''
A computer is basically a device that executes a set of commands--and does so very quickly.
Because the guts of a computer (a CPU) is kinda like a bunch of light switches--and I mean a *BUNCH* of light switches--it can only deal with a bunch of zeros and ones: a switch that is off is "zero," and a switch that's on is "one." 

NOTE: Never has the concept of a modern computer been so recklessly simplified. I feel shame.

All of the information a computer handles ultimately has to be represented by some combination of 1s and 0s, which we call a *binary* (or "base-two") number system. The chapters of this eBook are numbered using binary to show basic examples of the numbering system: 0001 is, well, 1 in decical. And 0100 is 4 in decimal. We won't get into binary numbers, but it's not very complicated and is kind of interesting if you're a nerd.

Imagine that your BFF is in your object-oriented programming class, but that cruel professor won't let you sit together.
When the professor turns his back, you can use your fingers to send a quick message to your BFF.
Holding up your index finger might mean, "meet me in the library after class;" two fingers could mean, "send me a copy of your homework."
As long as you agree on what each number means, you could pass along commands or information--it would be like your own little language.

Those commands that a computer can execute super fast?
Each command, or *instruction*, is represented by a number--a binary number, since that's the number system the computer uses.
The little language the computer understands is called *machine language*.

.Interesting
****
Just like people in different cultures use different languages, different CPU types use different languages. There are lots of different machine languages out there.
****

You could give the computer a set of instructions (aka, a program) if you just looked up the binary number for each instruction you wanted to use. 
Of course, even a simple program requires a lot of instructions, so you're going to be looking up a *lot* of stuff.

Few people actually _want_ to do that, so the rest of us use programming languages instead.

=== Programming Languages

A programming language is something that's easier for humans to use than machine language, but is capable of being accurately translated to machine language.

NOTE: There are many, many programming languages. https://en.wikipedia.org/wiki/List_of_programming_languages[Seriously, there are a lot].

The instructions you write using a programming language is called *source code*.
Translating source code file to a machine language file that can be executed is called *compiling*, and is done by an application called a compiler.
When the computer runs the program, it's using that machine language translation created by the compiler.
Clicking on the icon to run Microsoft Word runs a file that's been compiled from source code.

// TODO: Move to new channel
.Time To Watch!
****
Overview of Programming Languages and Compiling

video::PR6u4KvAkas[youtube, list=PL7yAQImwCConGySAAC5r3AB1tFDMFM3fw]
****


Some programming languages don't get translated ahead of time--they get translated "on the fly," as the program is running.
That's called *interpreting* instead of compiling.

The C programming language is an example of a compiled language, and Python is an example of an interpreted language. 

Java is an interesting case, because it's both compiled *and* interpreted. 
The JDK compiles your source code into an intermediate language called *bytecode*. 
To execute the program, you use the Java Runtime Environment to interpret that bytecode file as it executes.

Bytecode is very close to machine language. 
In fact, it's basically a "virtual machine language"--a machine language for a CPU that doesn't actually exist. 
This approach allows Java to be cross-platform (runnable on many different machines). 
A compiled machine language file only works on a computer that "speaks" the same machine language, but if you compile your program to a bytecode file, it'll run on any computer that has the Java Runtime Environment installed--and that will interpret the bytecode as it executes. 
This "write once, run anywhere" ability contributes greatly to Java's popularity.

=== Programming Paradigms

Programming para-what-now?

Imagine that your long-lost uncle died and left you his giant collection of vinyl records. Or imagine it's books, if that's what you prefer.
He also left you a bunch of money that can only be used buy whatever shelves, racks, and bins you need to store them. 
How would you organize the collection? 
You could group them by artist and then arrange them alphabetically, from https://youtu.be/xFrGuyw1V8s?si=2N4W5250-YP5Pdth[ABBA] to https://youtu.be/F2HH7J-Sx80?si=ByL5Vr4VVYmDA8Rv[Warren Zevon].
You could group them by genres (keeping disco separate from rock \'n' roll), or just put them in the order they were released.

There are tons of different ways to do it. 
None of them are really right or wrong, it just depends on what you prefer--or maybe on how you plan to find things later. 
Coding is similar, in that we all have different ways we imagine organizing a program or solving a problem. 
That's kinda the idea of a programming paradigm: how do you think about the program you're creating? How do you picture it being organized?

Just like programming languages, paradigms are numerous. 
In fact, some languages were created specifically to work well with a certain paradigm, and that's one reason there are so many languages. 
But when someone is going to learn to code, there are often two paradigms we consider:

* Procedural Programming
* Object-Oriented Programming (OOP)

// Procedural Programming:: a program is made up of procedures (you might use the term *functions*), and those procedures call each other during program execution.
// Object-Oriented Programming (OOP):: a program is made up of objects that have behaviors and related data, and those objects interact with one another during program execution.

They have a lot in common, and in fact OOP is actually a type of procedural programming.
Programmers love to argue why that approach is better than the other, in the same way some of my friends might argue about Ford trucks vs. Chevy trucks.
And just like Ford vs. Chevy, there's nothing inherently better about one paradigm or the other--sorry friends, Ford and Chevy trucks really are basically the same.
Growing up, my own first coding experiences were exclusively with procedural programming, and I stayed in that world until I began teaching Java--now I very much prefer OOP, both for my own programming and for teaching beginning coders.
But that really is a personal preference, and I wouldn't argue that OOP is _better_ than procedural programming.
Well, I wouldn't argue _much_. 

==== Comparing Procedural Programming and OOP

In procedural programming, we break up a program into the tasks we need to complete. 
Each individual task is handled by a set of statements that we call a *procedure*. 

The data for your program--the stuff you're keeping track of--is stored somewhere else. 
If a procedure needs something to complete its task, that data is sent to the procedure, which then sends back a result. 
In short, information is kept separate from the code that uses it and is passed back-and-forth as necessary.

.Procedural Programming
image::ProceduralProgramming.png[Diagram of procedural programming, 400]

Many programming languages (including Python) refer to procedures as *functions*, and the term *subroutines* is also used in some cases; if you've done some programming in any language, you've almost certainly used procedures in some form.

In OOP, the focus shifts from procedures to *objects, which are programming elements that bundle data with the procedures that use it, in contrast to procedural programming.
We'll explore the nature of objects in great detail going forward, so we won't worry about describing it too much for now.

I have my own biases about the topic.
I tend to think OOP lends itself especially well to things like graphical-user interfaces (GUIs) and games, as well as large projects developed by teams of programmers.

The bottom line is that, when faced with a programming task or project, my brain immediately starts thinking in terms of the objects the program will need.
But that's probably just a matter of habit; as I mentioned, I spent much of my life (including all of the time I spent as a professional programmer) seeing programs as a bunch of procedures. 

It's important that you're aware of procedural programming, and we'll refer to it occasionally, but our focus in this book and course is really on OOP.

=== Software Development Process

Learning to write code means creating a lot of programs--mostly small, straightforward programs at first. 
Remember those awful word problems where a train leaves Chicago traveling 40mph, and another train leaves Denver at 35mph?
That kind of stuff; but in my course, we don't get too caught up in the math part of it.
We care about understanding the requirements of a program and implementing it successfully.

As your programs become bigger and more complex, you'll need to work within a deliberate design and implementation process in order to keep yourself organized and focused.
Even the smaller programs you'll develop while learning the basics will benefit from a specific approach beyond just opening a new file and starting to type.
It ensures that you use your time efficiently.
And when you are faced with solving a programming problem that really intimidates you, the process will help make the task more approachable.

For big or small projects, a good general approach to software development is:

Analysis:: Identify the goals and scope of the program. As a rule, keep it small and focused--you can always add features later. _What does this program need to do?_
Testing Plan:: Determine how the final program will be tested. The testing plan will be useful, but most importantly, taking the time to establish a specific testing plan ensures that you thoroughly understand the program before you begin writing code. If you don't know how the program will work, you're not yet ready to begin coding. _How will I make sure the program works correctly?_
Implementation:: Write and test the code. We say that this is an _iterative_ (or "repeating") process, meaning you'll write and test one small piece, staying with it until you know it's good. Then you'll move on to the next piece and repeat. _What code do I need in order to get the next part of the program working?_
Revise or maintain:: If your needs or program requirements change, you'll need to go back to the first step and begin planning the next version. If not, you'll need to monitor that the program continues to perform as expected over time. _What's next for this program?_

We'll flesh out this process as we go--and as our programs become more advanced.

=== First Java Program

Enough of that, let's try writing some code.

One of the (valid) criticisms of Java as a choice for beginners is that it's a little complicated to create your first program. 
In Python, you just open a file and write your first command; in recent versions, C# has added that ability as well.
But Java puts OOP front and center, and you can't start writing statements until you first define a class.


// TODO: Move to new channel
.Time To Watch!
****
Java Course Folders and First Program

video::AKj8Jcy1zSc[youtube, list=PL7yAQImwCConGySAAC5r3AB1tFDMFM3fw]
File from video:

* https://raw.githubusercontent.com/timmcmichael/EMCCTimFiles/refs/heads/main/OOP%20with%20Java%20(CIS150AB)/HelloWorld.java[HelloWorld.java]
****


Take a look at the code for a basic "Hello World" program; we'll learn what all of these pieces are as we go, but we should at least identify them now.

// TODO: Add HelloWorld.java to shared folder

.HelloWorld.java - Hello World program in Java
[source,java]
----
include::source/HelloWorld.java[]

----
Here are the parts of the program:

<.> Class declaration and start of a code block. This is a publicly accessible class called `HelloWorld`.
<.> `main()` method declaration and start of a code block. `main()` is where a Java program starts running.
<.> `println()` statement to output the message.
<.> End of the `main()` method code black, as indicated by the indenting.
<.> End of the class code block.

You'll learn about all of these components as go.
But for now, you're off and running!